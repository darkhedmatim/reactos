Index: base/shell/explorer/desktop/desktop.cpp
===================================================================
--- base/shell/explorer/desktop/desktop.cpp	(revision 57368)
+++ base/shell/explorer/desktop/desktop.cpp	(working copy)
@@ -327,8 +327,8 @@
 HWND DesktopWindow::Create()
 {
 	static IconWindowClass wcDesktop(TEXT("Progman"), IDI_REACTOS, CS_DBLCLKS);
-	/* (disabled because of small ugly temporary artefacts when hiding start menu)
-	wcDesktop.hbrBackground = (HBRUSH)(COLOR_BACKGROUND+1); */
+	/* (disabled because of small ugly temporary artefacts when hiding start menu) */
+	wcDesktop.hbrBackground = (HBRUSH)(COLOR_BACKGROUND+1);
 
 	int width = GetSystemMetrics(SM_CXSCREEN);
 	int height = GetSystemMetrics(SM_CYSCREEN);
Index: cmake/baseaddress.cmake
===================================================================
--- cmake/baseaddress.cmake	(revision 57368)
+++ cmake/baseaddress.cmake	(working copy)
@@ -1,7 +1,7 @@
 set(baseaddress_ntdll                0x77f20000)
 set(baseaddress_kernel32             0x77da0000)
 set(baseaddress_msvcrt               0x77d10000)
-set(baseaddress_advapi32             0x77c60000)
+set(baseaddress_advapi32             0x77cb0000)
 set(baseaddress_gdi32                0x77bf0000)
 set(baseaddress_user32               0x77a60000)
 set(baseaddress_dhcpcsvc             0x77a10000)
@@ -296,3 +296,4 @@
 set(baseaddress_netevent             0x70a10000)
 set(baseaddress_tapiui               0x709b0000)
 set(baseaddress_iologmsg             0x669a0000)
+set(baseaddress_freetypd             0x709b0000)
Index: cmake/config.cmake
===================================================================
--- cmake/config.cmake	(revision 57368)
+++ cmake/config.cmake	(working copy)
@@ -26,7 +26,7 @@
 
 set(GDB FALSE CACHE BOOL
 "Whether to compile for debugging with GDB.
-If you don't use GDB, don't	enable this.")
+If you don't use GDB, don't enable this.")
 
 if(CMAKE_BUILD_TYPE STREQUAL "Release")
     set(DBG FALSE CACHE BOOL
@@ -56,6 +56,9 @@
 "Whether to compile support for ELF files.
 Do not enable unless you know what you're doing.")
 
+set(_ARWINSS_ TRUE CACHE BOOL
+"Whether to build and use Wine-based Win32 subsystem.")
+
 set(NSWPAT FALSE CACHE BOOL
 "Whether to compile apps/libs with features covered software patents or not.
 If you live in a country where software patents are valid/apply, don't
Index: cmake/gcc.cmake
===================================================================
--- cmake/gcc.cmake	(revision 57368)
+++ cmake/gcc.cmake	(working copy)
@@ -171,7 +171,7 @@
 
 SET(CMAKE_C_COMPILE_OBJECT "${CCACHE} <CMAKE_C_COMPILER> <DEFINES> <FLAGS> -o <OBJECT> -c <SOURCE>")
 SET(CMAKE_CXX_COMPILE_OBJECT "${CCACHE} <CMAKE_CXX_COMPILER>  <DEFINES> <FLAGS> -o <OBJECT> -c <SOURCE>")
-set(CMAKE_ASM_COMPILE_OBJECT "<CMAKE_ASM_COMPILER> -x assembler-with-cpp -o <OBJECT> -I${REACTOS_SOURCE_DIR}/include/asm -I${REACTOS_BINARY_DIR}/include/asm <FLAGS> <DEFINES> -D__ASM__ -c <SOURCE>")
+set(CMAKE_ASM_COMPILE_OBJECT "<CMAKE_ASM_COMPILER> -x assembler-with-cpp -o <OBJECT> -I\"${REACTOS_SOURCE_DIR}/include/asm\" -I\"${REACTOS_BINARY_DIR}/include/asm\" <FLAGS> <DEFINES> -D__ASM__ -c <SOURCE>")
 
 set(CMAKE_RC_COMPILE_OBJECT "<CMAKE_RC_COMPILER> -O coff <FLAGS> -DRC_INVOKED -D__WIN32__=1 -D__FLAT__=1 ${I18N_DEFS} <DEFINES> <SOURCE> <OBJECT>")
 set(CMAKE_DEPFILE_FLAGS_RC "--preprocessor \"${MINGW_TOOLCHAIN_PREFIX}gcc -E -xc-header -MMD -MF <DEPFILE> -MT <OBJECT>\" ")
@@ -353,7 +353,7 @@
 
     add_custom_command(
         OUTPUT ${_object_file}
-        COMMAND ${CMAKE_ASM_COMPILER} -x assembler-with-cpp -o ${_object_file} -I${REACTOS_SOURCE_DIR}/include/asm -I${REACTOS_BINARY_DIR}/include/asm -D__ASM__ -c ${_asm_file}
+        COMMAND ${CMAKE_ASM_COMPILER} -x assembler-with-cpp -o ${_object_file} -I\"${REACTOS_SOURCE_DIR}/include/asm\" -I\"${REACTOS_BINARY_DIR}/include/asm\" -D__ASM__ -c ${_asm_file}
         DEPENDS ${_asm_file})
 
     add_custom_command(
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 57368)
+++ CMakeLists.txt	(working copy)
@@ -126,16 +126,20 @@
         add_definitions(-D_WINKD_=1)
     endif()
 
+    if(_ARWINSS_)
+        add_definitions(-D_ARWINSS_=1)
+    endif()
+
     if(USE_PSEH3)
         add_definitions(-D_USE_PSEH3=1)
     endif()
 
     # Version Options
-    add_definitions(-DWINVER=0x502
+    add_definitions(-DWINVER=0x600
                     -D_WIN32_IE=0x600
-                    -D_WIN32_WINNT=0x502
-                    -D_WIN32_WINDOWS=0x502
-                    -D_SETUPAPI_VER=0x502)
+                    -D_WIN32_WINNT=0x600
+                    -D_WIN32_WINDOWS=0x600
+                    -D_SETUPAPI_VER=0x600)
 
     # Arch Options
     if(ARCH STREQUAL "i386")
@@ -245,6 +249,9 @@
     add_subdirectory(ntoskrnl)
     add_subdirectory(subsystems)
     add_subdirectory(win32ss)
+    if (_ARWINSS_)
+        add_subdirectory(arwinss)
+    endif()
 
     file(MAKE_DIRECTORY ${REACTOS_BINARY_DIR}/include/reactos)
 
Index: drivers/filesystems/npfs/create.c
===================================================================
--- drivers/filesystems/npfs/create.c	(revision 57368)
+++ drivers/filesystems/npfs/create.c	(working copy)
@@ -226,6 +226,9 @@
     }
 
     Ccb->FileObject = FileObject;
+    KeInitializeEvent(&Ccb->ConnectEvent, SynchronizationEvent, FALSE);
+    KeInitializeEvent(&Ccb->ReadEvent, NotificationEvent, FALSE);
+    KeInitializeEvent(&Ccb->WriteEvent, NotificationEvent, FALSE);
 
     FileObject->FsContext = Fcb;
     FileObject->FsContext2 = Ccb;
Index: include/asm/syscalls.inc
===================================================================
--- include/asm/syscalls.inc	(revision 57368)
+++ include/asm/syscalls.inc	(working copy)
@@ -95,6 +95,7 @@
 
 MACRO(STUB_U, Name, ArgCount)
     MAKE_LABEL Zw&Name, %ArgCount * 4
+    MAKE_LABEL Name, %ArgCount * 4
     START_PROC Nt&Name, %ArgCount * 4
     STUBCODE_U Name, SyscallId, %ArgCount
     .ENDP
@@ -102,6 +103,7 @@
 ENDM
 
 MACRO(STUB_K, Name, ArgCount)
+    MAKE_LABEL Name, %ArgCount * 4
     START_PROC Zw&Name, %ArgCount * 4
     STUBCODE_K Name, SyscallId, %ArgCount
     .ENDP
Index: include/psdk/winddi.h
===================================================================
--- include/psdk/winddi.h	(revision 57368)
+++ include/psdk/winddi.h	(working copy)
@@ -2665,7 +2665,7 @@
     _In_ ULONG cjSize,
     _Out_bytecap_(cjSize) FONTINFO *pfi);
 
-#if (NTDDI_VERSION <= NTDDI_WINXP)
+#if 0//(NTDDI_VERSION <= NTDDI_WINXP)
 GAMMA_TABLES*
 APIENTRY
 FONTOBJ_pGetGammaTables(
Index: include/psdk/winuser.h
===================================================================
--- include/psdk/winuser.h	(revision 57368)
+++ include/psdk/winuser.h	(working copy)
@@ -2818,8 +2818,8 @@
 typedef LRESULT(CALLBACK *HOOKPROC)(int,WPARAM,LPARAM);
 typedef BOOL(CALLBACK *PROPENUMPROCA)(HWND,LPCSTR,HANDLE);
 typedef BOOL(CALLBACK *PROPENUMPROCW)(HWND,LPCWSTR,HANDLE);
-typedef BOOL(CALLBACK *PROPENUMPROCEXA)(HWND,LPSTR,HANDLE,DWORD);
-typedef BOOL(CALLBACK *PROPENUMPROCEXW)(HWND,LPWSTR,HANDLE,DWORD);
+typedef BOOL(CALLBACK *PROPENUMPROCEXA)(HWND,LPSTR,HANDLE,ULONG_PTR);
+typedef BOOL(CALLBACK *PROPENUMPROCEXW)(HWND,LPWSTR,HANDLE,ULONG_PTR);
 typedef int(CALLBACK *EDITWORDBREAKPROCA)(LPSTR,int,int,int);
 typedef int(CALLBACK *EDITWORDBREAKPROCW)(LPWSTR,int,int,int);
 typedef LRESULT(CALLBACK *WNDPROC)(HWND,UINT,WPARAM,LPARAM);
Index: include/reactos/wine/config.h
===================================================================
--- include/reactos/wine/config.h	(revision 57368)
+++ include/reactos/wine/config.h	(working copy)
@@ -1,3 +1,5 @@
+#include "reactos/buildno.h"
+
 #define __WINE_CONFIG_H
 
 /* Define to a function attribute for Microsoft hotpatch assembly prefix. */
Index: lib/3rdparty/CMakeLists.txt
===================================================================
--- lib/3rdparty/CMakeLists.txt	(revision 57368)
+++ lib/3rdparty/CMakeLists.txt	(working copy)
@@ -3,7 +3,9 @@
 add_subdirectory(bzip2)
 add_subdirectory(cardlib)
 add_subdirectory(expat)
+if (NOT _ARWINSS_)
 add_subdirectory(freetype)
+endif ()
 add_subdirectory(fullfat)
 add_subdirectory(libmpg123)
 add_subdirectory(libsamplerate)
Index: lib/3rdparty/freetype/CMakeLists.txt
===================================================================
--- lib/3rdparty/freetype/CMakeLists.txt	(revision 57368)
+++ lib/3rdparty/freetype/CMakeLists.txt	(working copy)
@@ -11,7 +11,9 @@
   src/base/ftbbox.c
   src/base/ftbdf.c
   src/base/ftbitmap.c
+  src/base/ftcid.c
   src/base/ftdebug.c
+  src/base/ftfstype.c
   src/base/ftgasp.c
   src/base/ftglyph.c
   src/base/ftgxval.c
Index: win32ss/CMakeLists.txt
===================================================================
--- win32ss/CMakeLists.txt	(revision 57368)
+++ win32ss/CMakeLists.txt	(working copy)
@@ -10,10 +10,12 @@
     add_subdirectory(gdi/diblib)
 endif()
 
+add_subdirectory(user/win32csr)
+
+if (NOT _ARWINSS_)
 add_subdirectory(gdi/gdi32)
 add_subdirectory(reactx)
 add_subdirectory(user/user32)
-add_subdirectory(user/win32csr)
 
 spec2def(win32k.sys win32k.spec ADD_IMPORTLIB)
 
@@ -227,3 +229,5 @@
 
 add_library(win32ksys sys-stubs.S)
 set_source_files_properties(sys-stubs.S PROPERTIES OBJECT_DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/w32ksvc.h)
+
+endif() # _ARWINSS_
\ No newline at end of file
Index: win32ss/drivers/CMakeLists.txt
===================================================================
--- win32ss/drivers/CMakeLists.txt	(revision 57368)
+++ win32ss/drivers/CMakeLists.txt	(working copy)
@@ -1,5 +1,7 @@
 
 add_subdirectory(displays)
+if (NOT _ARWINSS_)
 add_subdirectory(font)
+endif ()
 add_subdirectory(miniport)
 add_subdirectory(videoprt)
Index: win32ss/include/ntgdihdl.h
===================================================================
--- win32ss/include/ntgdihdl.h	(revision 57368)
+++ win32ss/include/ntgdihdl.h	(working copy)
@@ -270,6 +270,7 @@
     DWORD           dwCFCount;
 } GDI_SHARED_HANDLE_TABLE, *PGDI_SHARED_HANDLE_TABLE;
 
+#ifndef _ARWINSS_
 typedef struct _RGN_ATTR
 {
     ULONG AttrFlags;
@@ -357,6 +358,19 @@
     RGN_ATTR VisRectRegion;
 } DC_ATTR, *PDC_ATTR;
 
+#else
+
+typedef struct _DC_ATTR
+{
+    HDC  hdc;
+    HDC  hKernelDC;
+    RECT dc_rect;     /* DC rectangle relative to drawable */
+    HRGN region;      /* Device region (visible region & clip region) */
+    int  cache_index; /* cache of a currently selected font */
+} DC_ATTR, *PDC_ATTR;
+
+#endif
+
 typedef struct _BRUSH_ATTR /* Used with pen too. */
 {
     FLONG    AttrFlags;
Index: win32ss/user/win32csr/CMakeLists.txt
===================================================================
--- win32ss/user/win32csr/CMakeLists.txt	(revision 57368)
+++ win32ss/user/win32csr/CMakeLists.txt	(working copy)
@@ -22,6 +22,7 @@
     file.c
     guiconsole.c
     handle.c
+    input.c
     harderror.c
     lineinput.c
     tuiconsole.c
Index: win32ss/user/win32csr/desktopbg.c
===================================================================
--- win32ss/user/win32csr/desktopbg.c	(revision 57368)
+++ win32ss/user/win32csr/desktopbg.c	(working copy)
@@ -53,7 +53,9 @@
 
 static BOOL BgInitialized = FALSE;
 static HWND VisibleDesktopWindow = NULL;
-#if 0
+#ifdef _ARWINSS_
+static HWND BackgroundWnd;
+
 static
 LRESULT
 CALLBACK
@@ -82,7 +84,7 @@
         return (LRESULT)TRUE;
 
     case WM_CREATE:
-        NtUserSetWindowFNID(Wnd, FNID_DESKTOP); // Anti-ReactOS hack!
+        //NtUserSetWindowFNID(Wnd, FNID_DESKTOP); // Anti-ReactOS hack!
     case WM_CLOSE:
         return 0;
 
@@ -146,6 +148,7 @@
 FASTCALL
 DtbgInit(VOID)
 {
+#ifndef _ARWINSS_
     WNDCLASSEXW Class;
     ATOM ClassAtom;
 
@@ -172,9 +175,19 @@
 
         return FALSE;
     }
-
+#endif
     VisibleDesktopWindow = NULL;
 
+#ifdef _ARWINSS_
+    /* set winstation if we don't have one yet */
+    if (!GetProcessWindowStation())
+    {
+        static const WCHAR WinSta0[] = {'W','i','n','S','t','a','0',0};
+        HANDLE handle = OpenWindowStationW(WinSta0, FALSE, WINSTA_ALL_ACCESS);
+        if (handle) SetProcessWindowStation(handle);
+    }
+#endif
+
     return TRUE;
 }
 #endif
@@ -183,7 +196,9 @@
 WINAPI
 DtbgDesktopThread(PVOID Data)
 {
+#ifndef _ARWINSS_
     HWND BackgroundWnd;
+#endif
     MSG msg;
     PDTBG_THREAD_DATA ThreadData = (PDTBG_THREAD_DATA)Data;
 
@@ -199,7 +214,7 @@
 
     BackgroundWnd = CreateWindowW((LPCWSTR)DESKTOP_WINDOW_ATOM,
                                   L"",
-                                  WS_POPUP | WS_CLIPCHILDREN,
+                                  WS_POPUP | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
                                   GetSystemMetrics(SM_XVIRTUALSCREEN),
                                   GetSystemMetrics(SM_YVIRTUALSCREEN),
                                   GetSystemMetrics(SM_CXVIRTUALSCREEN),
@@ -218,6 +233,9 @@
 
     DPRINT("BackgroundWnd 0x%p\n",BackgroundWnd);
 
+    /* Set window proc */
+    SetWindowLongPtrW( BackgroundWnd, GWLP_WNDPROC, (LONG_PTR)DtbgWindowProc );
+
     ThreadData->Status = STATUS_SUCCESS;
     SetEvent(ThreadData->Event);
 
@@ -245,9 +263,10 @@
     if (!BgInitialized)
     {
         BgInitialized = TRUE;
-
-       // if (!DtbgInit())
-       //     return STATUS_UNSUCCESSFUL;
+#ifdef _ARWINSS_
+        if (!DtbgInit())
+            return STATUS_UNSUCCESSFUL;
+#endif
     }
 
     /*
@@ -283,6 +302,28 @@
     WaitForSingleObject(ThreadData.Event, INFINITE);
     CloseHandle(ThreadData.Event);
 
+#ifdef _ARWINSS_
+    /* Show the desktop immediately */
+    {
+        PRIVATE_NOTIFY_DESKTOP nmh;
+
+        nmh.hdr.hwndFrom = BackgroundWnd;
+        nmh.hdr.idFrom = 0;
+        nmh.hdr.code = PM_SHOW_DESKTOP;
+
+        nmh.ShowDesktop.Width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
+        nmh.ShowDesktop.Height = GetSystemMetrics(SM_CYVIRTUALSCREEN);
+
+        SendMessageW(BackgroundWnd,
+                     WM_NOTIFY,
+                     (WPARAM)nmh.hdr.hwndFrom,
+                     (LPARAM)&nmh)
+            ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS;
+
+        RedrawWindow(BackgroundWnd, NULL, 0, RDW_INVALIDATE | RDW_FRAME | RDW_ERASENOW | RDW_ALLCHILDREN);
+    }
+#endif
+
     return ThreadData.Status;
 }
 
Index: win32ss/user/win32csr/dllmain.c
===================================================================
--- win32ss/user/win32csr/dllmain.c	(revision 57368)
+++ win32ss/user/win32csr/dllmain.c	(working copy)
@@ -16,6 +16,9 @@
 extern VOID WINAPI PrivateCsrssManualGuiCheck(LONG Check);
 extern LIST_ENTRY DosDeviceHistory;
 extern RTL_CRITICAL_SECTION Win32CsrDefineDosDeviceCritSec;
+#ifdef _ARWINSS_
+void CsrInitInputSupport();
+#endif
 
 /* GLOBALS *******************************************************************/
 
@@ -262,7 +265,9 @@
 //
 // HACK HACK HACK ReactOS to BOOT! Initialization BUG ALERT! See bug 5655.
 //
+#ifndef _ARWINSS_
         hhk = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHookProc, NULL, 0);
+#endif
 // BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT!
 //  BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT!
 //   BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT! BUG ALERT!
@@ -312,14 +317,18 @@
 WINAPI
 PrivateCsrssManualGuiCheck(LONG Check)
 {
+#ifndef _ARWINSS_
   NtUserCallOneParam(Check, ONEPARAM_ROUTINE_CSRSS_GUICHECK);
+#endif
 }
 
 DWORD
 WINAPI
 CreateSystemThreads(PVOID pParam)
 {
+#ifndef _ARWINSS_
     NtUserCallOneParam((DWORD)pParam, ONEPARAM_ROUTINE_CREATESYSTEMTHREADS);
+#endif
     DPRINT1("This thread should not terminate!\n");
     return 0;
 }
@@ -328,9 +337,11 @@
 WINAPI
 Win32CsrInitialization(IN PCSR_SERVER_DLL ServerDll)
 {
+#ifndef _ARWINSS_
     HANDLE ServerThread;
     CLIENT_ID ClientId;
     NTSTATUS Status;
+#endif
 
     Win32CsrApiHeap = RtlGetProcessHeap();
     
@@ -353,6 +364,9 @@
     InitializeListHead(&DosDeviceHistory);
 
     /* Start Raw Input Threads */
+#ifdef _ARWINSS_
+    CsrInitInputSupport();
+#else
     Status = RtlCreateUserThread(NtCurrentProcess(), NULL, TRUE, 0, 0, 0, (PTHREAD_START_ROUTINE)CreateSystemThreads, (PVOID)0, &ServerThread, &ClientId);
     if (NT_SUCCESS(Status))
     {
@@ -361,7 +375,7 @@
     }
     else
         DPRINT1("Cannot start Raw Input Thread!\n");
-
+#endif
     return STATUS_SUCCESS;
 }
 
Index: win32ss/user/win32csr/input.c
===================================================================
--- win32ss/user/win32csr/input.c	(revision 0)
+++ win32ss/user/win32csr/input.c	(working copy)
@@ -0,0 +1,387 @@
+/*
+ * PROJECT:     ReactOS CSRSS
+ * LICENSE:     GPL - See COPYING in the top level directory
+ * FILE:        subsystems/win32/csrss/api/input.c
+ * PURPOSE:     CSRSS input support 
+ * COPYRIGHT:   Casper S. Hornstrup (chorns@users.sourceforge.net)
+ *
+ *  this file is heavily based on subsystems\win32\win32k\ntuser\input.c from trunk
+ */
+
+#define NDEBUG
+#include "w32csr.h"
+#include <debug.h>
+#define NTOS_MODE_USER
+#include <ndk/iofuncs.h>
+#include <ntddmou.h>
+#include <ntddkbd.h>
+
+static HHOOK gKeyboardHook, gMouseHook;
+
+#define ClearMouseInput(mi) \
+  mi.dx = 0; \
+  mi.dy = 0; \
+  mi.mouseData = 0; \
+  mi.dwFlags = 0;
+
+#define SendMouseEvent(mi) \
+  if(mi.dx != 0 || mi.dy != 0) \
+    mi.dwFlags |= MOUSEEVENTF_MOVE; \
+  if(mi.dwFlags) \
+    mouse_event(mi.dwFlags,mi.dx,mi.dy, mi.mouseData, 0); \
+  ClearMouseInput(mi);
+
+
+static LRESULT CALLBACK DummyHookProc( INT code, WPARAM wparam, LPARAM lparam ){
+    return CallNextHookEx( 0, code, wparam, lparam );
+}
+
+
+VOID FASTCALL
+ProcessMouseInputData(PMOUSE_INPUT_DATA Data, ULONG InputCount)
+{
+    PMOUSE_INPUT_DATA mid;
+    MOUSEINPUT mi;
+    ULONG i;
+
+    ClearMouseInput(mi);
+    mi.time = 0;
+    mi.dwExtraInfo = 0;
+    for(i = 0; i < InputCount; i++)
+    {
+        mid = (Data + i);
+        mi.dx += mid->LastX;
+        mi.dy += mid->LastY;
+
+        /* Check if the mouse move is absolute */
+        if (mid->Flags == MOUSE_MOVE_ABSOLUTE)
+        {
+            /* Set flag and convert to screen location */
+            mi.dwFlags |= MOUSEEVENTF_ABSOLUTE;
+            mi.dx = mi.dx / (65535 / (GetSystemMetrics(SM_CXVIRTUALSCREEN) - 1));
+            mi.dy = mi.dy / (65535 / (GetSystemMetrics(SM_CYVIRTUALSCREEN) - 1));
+        }
+
+        if(mid->ButtonFlags)
+        {
+            if(mid->ButtonFlags & MOUSE_LEFT_BUTTON_DOWN)
+            {
+                mi.dwFlags |= MOUSEEVENTF_LEFTDOWN;
+                SendMouseEvent(mi);
+            }
+            if(mid->ButtonFlags & MOUSE_LEFT_BUTTON_UP)
+            {
+                mi.dwFlags |= MOUSEEVENTF_LEFTUP;
+                SendMouseEvent(mi);
+            }
+            if(mid->ButtonFlags & MOUSE_MIDDLE_BUTTON_DOWN)
+            {
+                mi.dwFlags |= MOUSEEVENTF_MIDDLEDOWN;
+                SendMouseEvent(mi);
+            }
+            if(mid->ButtonFlags & MOUSE_MIDDLE_BUTTON_UP)
+            {
+                mi.dwFlags |= MOUSEEVENTF_MIDDLEUP;
+                SendMouseEvent(mi);
+            }
+            if(mid->ButtonFlags & MOUSE_RIGHT_BUTTON_DOWN)
+            {
+                mi.dwFlags |= MOUSEEVENTF_RIGHTDOWN;
+                SendMouseEvent(mi);
+            }
+            if(mid->ButtonFlags & MOUSE_RIGHT_BUTTON_UP)
+            {
+                mi.dwFlags |= MOUSEEVENTF_RIGHTUP;
+                SendMouseEvent(mi);
+            }
+            if(mid->ButtonFlags & MOUSE_BUTTON_4_DOWN)
+            {
+                mi.mouseData |= XBUTTON1;
+                mi.dwFlags |= MOUSEEVENTF_XDOWN;
+                SendMouseEvent(mi);
+            }
+            if(mid->ButtonFlags & MOUSE_BUTTON_4_UP)
+            {
+                mi.mouseData |= XBUTTON1;
+                mi.dwFlags |= MOUSEEVENTF_XUP;
+                SendMouseEvent(mi);
+            }
+            if(mid->ButtonFlags & MOUSE_BUTTON_5_DOWN)
+            {
+                mi.mouseData |= XBUTTON2;
+                mi.dwFlags |= MOUSEEVENTF_XDOWN;
+                SendMouseEvent(mi);
+            }
+            if(mid->ButtonFlags & MOUSE_BUTTON_5_UP)
+            {
+                mi.mouseData |= XBUTTON2;
+                mi.dwFlags |= MOUSEEVENTF_XUP;
+                SendMouseEvent(mi);
+            }
+            if(mid->ButtonFlags & MOUSE_WHEEL)
+            {
+                mi.mouseData = mid->ButtonData;
+                mi.dwFlags |= MOUSEEVENTF_WHEEL;
+                SendMouseEvent(mi);
+            }
+        }
+    }
+
+    SendMouseEvent(mi);
+}
+
+DWORD WINAPI MouseInputThread(LPVOID lpParameter)
+{
+    UNICODE_STRING MouseDeviceName = RTL_CONSTANT_STRING(L"\\Device\\PointerClass0");
+    OBJECT_ATTRIBUTES MouseObjectAttributes;
+    IO_STATUS_BLOCK Iosb;
+    HANDLE MouseDeviceHandle;
+    NTSTATUS Status;
+
+    InitializeObjectAttributes(&MouseObjectAttributes,
+                              &MouseDeviceName,
+                              0,
+                              NULL,
+                              NULL);
+
+    do
+    {
+        Sleep(1000);
+        Status = NtOpenFile(&MouseDeviceHandle,
+                            FILE_ALL_ACCESS,
+                            &MouseObjectAttributes,
+                            &Iosb,
+                            0,
+                            FILE_SYNCHRONOUS_IO_ALERT);
+    } while (!NT_SUCCESS(Status));
+
+    while(1)
+    {
+        MOUSE_INPUT_DATA MouseInput;
+        Status = NtReadFile(MouseDeviceHandle,
+                            NULL,
+                            NULL,
+                            NULL,
+                            &Iosb,
+                            &MouseInput,
+                            sizeof(MOUSE_INPUT_DATA),
+                            NULL,
+                            NULL);
+        //if(Status == STATUS_ALERTED)
+        //{
+        //   break;
+        //}
+        if(Status == STATUS_PENDING)
+        {
+            NtWaitForSingleObject(MouseDeviceHandle, FALSE, NULL);
+            Status = Iosb.Status;
+        }
+        if(!NT_SUCCESS(Status))
+        {
+            DPRINT1("Win32K: Failed to read from mouse.\n");
+            return Status;
+        }
+        DPRINT("MouseEvent\n");
+
+        if(!gMouseHook)
+            gMouseHook = SetWindowsHookEx(WH_MOUSE_LL, DummyHookProc, NULL, 0);
+
+        ProcessMouseInputData(&MouseInput, Iosb.Information / sizeof(MOUSE_INPUT_DATA));
+    }
+}
+
+/* Sends the keyboard commands to turn on/off the lights.
+ */
+static NTSTATUS APIENTRY
+IntKeyboardUpdateLeds(HANDLE KeyboardDeviceHandle,
+                      PKEYBOARD_INPUT_DATA KeyInput,
+                      PKEYBOARD_INDICATOR_TRANSLATION IndicatorTrans)
+{
+    NTSTATUS Status;
+    UINT Count;
+    static KEYBOARD_INDICATOR_PARAMETERS Indicators;
+    IO_STATUS_BLOCK Block;
+
+    if (!IndicatorTrans)
+        return STATUS_NOT_SUPPORTED;
+
+    if (KeyInput->Flags & (KEY_E0 | KEY_E1 | KEY_BREAK))
+        return STATUS_SUCCESS;
+
+    for (Count = 0; Count < IndicatorTrans->NumberOfIndicatorKeys; Count++)
+    {
+        if (KeyInput->MakeCode == IndicatorTrans->IndicatorList[Count].MakeCode)
+        {
+            Indicators.LedFlags ^=
+                IndicatorTrans->IndicatorList[Count].IndicatorFlags;
+
+            /* Update the lights on the hardware */
+
+            Status = NtDeviceIoControlFile(KeyboardDeviceHandle,
+                                           NULL,
+                                           NULL,
+                                           NULL,
+                                           &Block,
+                                           IOCTL_KEYBOARD_SET_INDICATORS,
+                                           &Indicators, sizeof(Indicators),
+                                           NULL, 0);
+
+            return Status;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
+
+/* Asks the keyboard driver to send a small table that shows which
+ * lights should connect with which scancodes
+ */
+static NTSTATUS APIENTRY
+IntKeyboardGetIndicatorTrans(HANDLE KeyboardDeviceHandle,
+                             PKEYBOARD_INDICATOR_TRANSLATION *IndicatorTrans)
+{
+    NTSTATUS Status;
+    DWORD Size = 0;
+    IO_STATUS_BLOCK Block;
+    PKEYBOARD_INDICATOR_TRANSLATION Ret;
+
+    Size = sizeof(KEYBOARD_INDICATOR_TRANSLATION);
+
+    Ret = HeapAlloc(Win32CsrApiHeap, 0, Size);
+
+    while (Ret)
+    {
+        Status = NtDeviceIoControlFile(KeyboardDeviceHandle,
+                                       NULL,
+                                       NULL,
+                                       NULL,
+                                       &Block,
+                                       IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION,
+                                       NULL,
+                                       0,
+                                       Ret, Size);
+
+        if (Status != STATUS_BUFFER_TOO_SMALL)
+            break;
+
+        HeapFree(Win32CsrApiHeap, 0, Ret);
+
+        Size += sizeof(KEYBOARD_INDICATOR_TRANSLATION);
+
+        Ret = HeapAlloc(Win32CsrApiHeap, 0, Size);
+    }
+
+    if (!Ret)
+        return STATUS_INSUFFICIENT_RESOURCES;
+
+    if (Status != STATUS_SUCCESS)
+    {
+        HeapFree(Win32CsrApiHeap, 0, Ret);
+        return Status;
+    }
+
+    *IndicatorTrans = Ret;
+    return Status;
+}
+
+DWORD WINAPI KeyboardInputThread(LPVOID lpParameter)
+{
+    UNICODE_STRING KeyboardDeviceName = RTL_CONSTANT_STRING(L"\\Device\\KeyboardClass0");
+    OBJECT_ATTRIBUTES KeyboardObjectAttributes;
+    IO_STATUS_BLOCK Iosb;
+    HANDLE KeyboardDeviceHandle;
+    NTSTATUS Status;
+    PKEYBOARD_INDICATOR_TRANSLATION IndicatorTrans = NULL;
+
+    InitializeObjectAttributes(&KeyboardObjectAttributes,
+                               &KeyboardDeviceName,
+                               0,
+                               NULL,
+                               NULL);
+
+    do
+    {
+        Sleep(1000);
+        Status = NtOpenFile(&KeyboardDeviceHandle,
+                            FILE_ALL_ACCESS,
+                            &KeyboardObjectAttributes,
+                            &Iosb,
+                            0,
+                            FILE_SYNCHRONOUS_IO_ALERT);
+    } while (!NT_SUCCESS(Status));
+
+    IntKeyboardGetIndicatorTrans(KeyboardDeviceHandle,
+        &IndicatorTrans);
+    while(1)
+    {
+        KEYBOARD_INPUT_DATA KeyInput;
+        DWORD flags;
+
+        Status = NtReadFile(KeyboardDeviceHandle,
+                            NULL,
+                            NULL,
+                            NULL,
+                            &Iosb,
+                            &KeyInput,
+                            sizeof(KEYBOARD_INPUT_DATA),
+                            NULL,
+                            NULL);
+
+        if(Status == STATUS_ALERTED)
+        {
+            break;
+        }
+        if(Status == STATUS_PENDING)
+        {
+            NtWaitForSingleObject(KeyboardDeviceHandle, FALSE, NULL);
+            Status = Iosb.Status;
+        }
+        if(!NT_SUCCESS(Status))
+        {
+            DPRINT1("Win32K: Failed to read from mouse.\n");
+            return Status;
+        }
+
+        DPRINT("KeyRaw: %s %04x\n",
+            (KeyInput.Flags & KEY_BREAK) ? "up" : "down",
+            KeyInput.MakeCode );
+
+        if (!NT_SUCCESS(Status))
+        {
+            DPRINT1("Win32K: Failed to read from keyboard.\n");
+            return Status;
+        }
+
+        IntKeyboardUpdateLeds(KeyboardDeviceHandle,
+                              &KeyInput,
+                              IndicatorTrans);
+
+        flags = 0;
+
+        if (KeyInput.Flags & KEY_E0)
+            flags |= KEYEVENTF_EXTENDEDKEY;
+
+        if (KeyInput.Flags & KEY_BREAK)
+            flags |= KEYEVENTF_KEYUP;
+
+        if(!gKeyboardHook)
+            gKeyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, DummyHookProc, NULL, 0);
+
+        keybd_event(MapVirtualKey(KeyInput.MakeCode & 0xff, MAPVK_VSC_TO_VK), KeyInput.MakeCode & 0xff, flags , 0);
+    }
+
+    return Status;
+}
+
+
+void CsrInitInputSupport()
+{
+    HANDLE MouseThreadHandle, KeyboardThreadHandle;
+
+    ClipCursor(NULL);
+
+    MouseThreadHandle = CreateThread(NULL, 0, MouseInputThread, NULL, 0,NULL);
+    KeyboardThreadHandle = CreateThread(NULL, 0, KeyboardInputThread, NULL, 0,NULL);
+}
+
+/* EOF */
Index: win32ss/user/win32csr/input.c
===================================================================
--- win32ss/user/win32csr/input.c	(revision 48725)
+++ win32ss/user/win32csr/input.c	(working copy)

Property changes on: win32ss/user/win32csr/input.c
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
