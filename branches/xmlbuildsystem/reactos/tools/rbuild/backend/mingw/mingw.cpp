
#include "../../pch.h"

#include "mingw.h"

using std::string;
using std::vector;

static class MingwFactory : public Backend::Factory
{
public:
	MingwFactory() : Factory ( "mingw" ) {}
	Backend* operator() ( Project& project )
	{
		return new MingwBackend ( project );
	}
} factory;


MingwBackend::MingwBackend ( Project& project )
	: Backend ( project )
{
}

void
MingwBackend::Process ()
{
	CreateMakefile ();
	GenerateHeader ();
	GenerateGlobalVariables ();
	GenerateAllTarget ();
	for ( size_t i = 0; i < ProjectNode.modules.size (); i++ )
	{
		Module& module = *ProjectNode.modules[i];
		ProcessModule ( module );
	}
	CloseMakefile ();
}

void
MingwBackend::CreateMakefile ()
{
	fMakefile = fopen ( ProjectNode.makefile.c_str (), "w" );
	if ( !fMakefile )
		throw AccessDeniedException ( ProjectNode.makefile );
	MingwModuleHandler::SetMakefile ( fMakefile );
}

void
MingwBackend::CloseMakefile ()
{
	if (fMakefile)
		fclose ( fMakefile );
}

void
MingwBackend::GenerateHeader ()
{
	fprintf ( fMakefile, "# THIS FILE IS AUTOMATICALLY GENERATED, EDIT 'ReactOS.xml' INSTEAD\n\n" );
}

string
MingwBackend::GenerateProjectCFLAGS ()
{
	size_t i;
	string clags;
	for ( i = 0; i < ProjectNode.includes.size (); i++ )
	{
		Include& include = *ProjectNode.includes[i];
		if (clags.length () > 0)
			clags += " ";
		clags += "-I" + include.directory;
	}
	
	for ( i = 0; i < ProjectNode.defines.size (); i++ )
	{
		Define& define = *ProjectNode.defines[i];
		if ( clags.length () > 0 )
			clags += " ";
		clags += "-D" + define.name;
		if ( define.value.size() > 0 )
		{
			clags += "=";
			clags += define.value;
		}
	}
	return clags;
}

void
MingwBackend::GenerateGlobalVariables ()
{
	size_t i;

	fprintf ( fMakefile, "host_gcc = gcc\n" );
	fprintf ( fMakefile, "host_ar = ar\n" );
	fprintf ( fMakefile, "host_ld = ld\n" );
	fprintf ( fMakefile, "rm = del /f /q\n" );
	fprintf ( fMakefile, "gcc = gcc\n" );
	fprintf ( fMakefile, "ld = ld\n" );
	fprintf ( fMakefile, "ar = ar\n" );
	fprintf ( fMakefile, "dlltool = dlltool\n" );
	fprintf ( fMakefile, "PROJECT_CFLAGS = %s\n", GenerateProjectCFLAGS ().c_str () );
	for ( i = 0; i < ProjectNode.properties.size(); i++ )
	{
		Property& prop = *ProjectNode.properties[i];
		fprintf ( fMakefile, "%s := %s\n",
			prop.name.c_str(),
			prop.value.c_str() );
	}
	fprintf ( fMakefile, "\n" );
}

void
MingwBackend::GenerateAllTarget ()
{
	fprintf ( fMakefile, "all:" );
	for ( size_t i = 0; i < ProjectNode.modules.size (); i++ )
	{
		Module& module = *ProjectNode.modules[i];
		fprintf ( fMakefile,
		          " %s",
		          FixupTargetFilename ( module.GetPath () ).c_str () );
	}
	fprintf ( fMakefile, "\n\t\n\n" );
}

void
MingwBackend::ProcessModule ( Module& module )
{
	MingwModuleHandler* h = MingwModuleHandler::LookupHandler (
		module.node.location,
		module.type );
	h->Process ( module );
}

string
FixupTargetFilename ( const string& targetFilename )
{
	return string("$(ROS_INTERMEDIATE)") + targetFilename;
}
