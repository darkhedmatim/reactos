
#include "pch.h"

#include "rbuild.h"

using std::string;
using std::vector;

#ifdef WIN32
#define EXEPOSTFIX ".exe"
#define SEP "\\"
string FixSep ( const string& s )
{
	string s2(s);
	char* p = strchr ( &s2[0], '/' );
	while ( p )
	{
		*p++ = '\\';
		p = strchr ( p, '/' );
	}
	return s2;
}
#else
#define EXEPOSTFIX
#define SEP "/"
string FixSep ( const string& s )
{
	string s2(s);
	char* p = strchr ( &s2[0], '\\' );
	while ( p )
	{
		*p++ = '/';
		p = strchr ( p, '\\' );
	}
	return s2;
}
#endif

Project::Project()
{
}

Project::Project(const string& filename)
{
	if ( !xmlfile.open ( filename ) )
		throw FileNotFoundException ( filename );
	ReadXml();
}

Project::~Project()
{
	for ( size_t i = 0; i < modules.size(); i++ )
		delete modules[i];
	delete head;
}

void Project::ReadXml()
{
	Path path;

	head = XMLParse ( xmlfile, path );
	if ( !head )
		throw InvalidBuildFileException ( "Document contains no 'project' tag." );

	if ( head->name != "project" )
	{
		throw InvalidBuildFileException ( "Expected 'project', got '%s'.",
			                              head->name.c_str());
	}

	this->ProcessXML ( *head, "." );
}

void
Project::ProcessXML ( const XMLElement& e, const string& path )
{
	const XMLAttribute *att;
	string subpath(path);
	if ( e.name == "project" )
	{
		att = e.GetAttribute ( "name", false );
		if ( !att )
			name = "Unnamed";
		else
			name = att->value;
	}
	else if ( e.name == "module" )
	{
		att = e.GetAttribute ( "name", true );
		if ( !att )
			return;
		Module* module = new Module ( e, att->value, path );
		modules.push_back ( module );
		module->ProcessXML ( e, path );
		return;
	}
	else if ( e.name == "directory" )
	{
		// this code is duplicated between Project::ProcessXML() and Module::ProcessXML() :(
		const XMLAttribute* att = e.GetAttribute ( "name", true );
		if ( !att )
			return;
		subpath = path + "/" + att->value;
	}
	for ( size_t i = 0; i < e.subElements.size(); i++ )
		ProcessXML ( *e.subElements[i], subpath );
}

bool
Project::GenerateOutput()
{
	const XMLAttribute* att;
	size_t i;

	att = head->GetAttribute ( "makefile", true );
	if ( !att )
		return false;
	FILE* f = fopen ( att->value.c_str(), "w" );
	if ( !f )
	{
		throw Exception ( "Unable to open '%s' for output", att->value.c_str() );
		return false;
	}
	fprintf ( f, "# THIS FILE IS AUTOMATICALLY GENERATED, EDIT 'ReactOS.xml' INSTEAD\n\n" );

	// generate module list:
	fprintf ( f, "all: " );
	for ( i = 0; i < modules.size(); i++ )
	{
		Module& m = *modules[i];
		fprintf ( f, " %s" SEP "%s" EXEPOSTFIX, FixSep(m.path).c_str(), m.name.c_str() );
	}
	fprintf ( f, "\n\n" );

	return true;
}
