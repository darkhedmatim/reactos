Index: base/system/winlogon/winlogon.c
===================================================================
--- base/system/winlogon/winlogon.c	(revision 70340)
+++ base/system/winlogon/winlogon.c	(working copy)
@@ -397,7 +397,7 @@
         HandleShutdown(WLSession, WLX_SAS_ACTION_SHUTDOWN_REBOOT);
         ExitProcess(1);
     }
-
+ERR("WL Desktop: %x\n", WLSession->WinlogonDesktop);
     DisplayStatusMessage(WLSession, WLSession->WinlogonDesktop, IDS_REACTOSISSTARTINGUP);
 
 #if 0
Index: cmake/baseaddress.cmake
===================================================================
--- cmake/baseaddress.cmake	(revision 70340)
+++ cmake/baseaddress.cmake	(working copy)
@@ -2,9 +2,9 @@
 set(baseaddress_kernel32             0x7c750000)
 set(baseaddress_msvcrt               0x7c6b0000)
 set(baseaddress_advapi32             0x7c610000)
-set(baseaddress_gdi32                0x7c570000)
-set(baseaddress_user32               0x7c3d0000)
-set(baseaddress_dhcpcsvc             0x7c380000)
+set(baseaddress_gdi32                0x7c530000)
+set(baseaddress_user32               0x7c380000)
+set(baseaddress_dhcpcsvc             0x7cb80000)
 set(baseaddress_dnsapi               0x7c330000)
 set(baseaddress_icmp                 0x7c300000)
 set(baseaddress_iphlpapi             0x7c2b0000)
Index: cmake/config.cmake
===================================================================
--- cmake/config.cmake	(revision 70340)
+++ cmake/config.cmake	(working copy)
@@ -58,6 +58,9 @@
 "Whether to compile support for ELF files.
 Do not enable unless you know what you're doing.")
 
+set(_ARWINSS_ TRUE CACHE BOOL
+"Whether to build and use Wine-based Win32 subsystem.")
+
 set(NSWPAT FALSE CACHE BOOL
 "Whether to build apps/libs with features covered by software patents.
 If you live in a country where software patents are valid/apply, don't
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 70340)
+++ CMakeLists.txt	(working copy)
@@ -165,6 +165,10 @@
         add_definitions(-D_WINKD_=1)
     endif()
 
+    if(_ARWINSS_)
+        add_definitions(-D_ARWINSS_=1)
+    endif()
+
     if(CMAKE_VERSION MATCHES "ReactOS")
         set(PCH 1 CACHE BOOL "Whether to use precompiled headers")
     else()
@@ -278,6 +282,9 @@
     add_subdirectory(subsystems)
     add_subdirectory(tools/wpp)
     add_subdirectory(win32ss)
+    if (_ARWINSS_)
+        add_subdirectory(arwinss)
+    endif()
 
     # Create the registry hives
     create_registry_hives()
Index: dll/win32/kernel32/client/dllmain.c
===================================================================
--- dll/win32/kernel32/client/dllmain.c	(revision 70340)
+++ dll/win32/kernel32/client/dllmain.c	(working copy)
@@ -131,7 +131,7 @@
                          SessionId,
                          WIN_OBJ_DIR);
             }
-
+DPRINT1("About to connect to CSR!\n");
             /* Connect to the Base Server */
             Status = CsrClientConnectToServer(SessionDir,
                                               BASESRV_SERVERDLL_INDEX,
Index: dll/win32/msgina/gui.c
===================================================================
--- dll/win32/msgina/gui.c	(revision 70340)
+++ dll/win32/msgina/gui.c	(working copy)
@@ -73,6 +73,7 @@
 
     /* When SetThreadDesktop is called the system closes the desktop handle when needed
        so we have to create a new handle because this handle may still be in use by winlogon  */
+#ifndef _ARWINSS_
     if (!DuplicateHandle (  GetCurrentProcess(), 
                             msg->hDesktop, 
                             GetCurrentProcess(), 
@@ -85,6 +86,9 @@
         HeapFree(GetProcessHeap(), 0, lpParam);
         return FALSE;
     }
+#else
+    hDesk = msg->hDesktop;
+#endif
 
     if(!SetThreadDesktop(hDesk))
     {
@@ -118,6 +122,8 @@
 
     TRACE("GUIDisplayStatusMessage(%ws)\n", pMessage);
 
+	ERR("ARWINSS BIG BUG #1\n");
+return TRUE; // ARWINSS 1st bug
     if (!pgContext->hStatusWindow)
     {
         /*
Index: include/asm/syscalls.inc
===================================================================
--- include/asm/syscalls.inc	(revision 70340)
+++ include/asm/syscalls.inc	(working copy)
@@ -1,4 +1,4 @@
-
+
 #ifdef _M_ARM
 
 #include <ksarm.h>
@@ -52,103 +52,105 @@
 
 SyscallId = 0
 
-#ifdef _M_IX86
-#define KUSER_SHARED_SYSCALL HEX(7ffe0300)
-#define KGDT_R0_CODE 8
-MACRO(STUBCODE_U, Name, SyscallId, ArgCount)
-    StackBytes = 4 * ArgCount
-    FPO 0, 0, 0, 0, 0, FRAME_FPO
-    mov eax, SyscallId
+#ifdef _M_IX86
+#define KUSER_SHARED_SYSCALL HEX(7ffe0300)
+#define KGDT_R0_CODE 8
+MACRO(STUBCODE_U, Name, SyscallId, ArgCount)
+    StackBytes = 4 * ArgCount
+    FPO 0, 0, 0, 0, 0, FRAME_FPO
+    mov eax, SyscallId
     mov edx, KUSER_SHARED_SYSCALL
     call dword ptr [edx]
-    ret StackBytes
-ENDM
-MACRO(STUBCODE_K, Name, SyscallId, ArgCount)
-    StackBytes = 4 * &ArgCount
-    FPO 0, 0, 0, 0, 0, FRAME_FPO
-    mov eax, SyscallId
-    lea edx, [esp + 4]
-    pushfd
-    push KGDT_R0_CODE
-    call _KiSystemService
-    ret StackBytes
-ENDM
-#elif defined(_M_AMD64)
-MACRO(STUBCODE_U, Name, SyscallId, ArgCount)
-    .ENDPROLOG
-    mov eax, SyscallId
-    mov r10, rcx
-    syscall
-    ret
-ENDM
-MACRO(STUBCODE_K, Name, SyscallId, ArgCount)
-    .ENDPROLOG
-    EXTERN Nt&Name:PROC
-    lea rax, Nt&Name[rip]
-    mov r10, ArgCount * 8
-    jmp KiZwSystemService
-ENDM
-#elif defined(_M_PPC)
-MACRO(STUBCODE_U, Name, SyscallId, ArgCount)
-    stwu 1,-16(1)
-    mflr 0
-    stw  0,0(1)
-    li   0, SyscallId
-    sc
-    lwz 0,0(1)
-    mtlr 0
-    addi 1,1,16
-    blr
-ENDM
-#define STUBCODE_K STUBCODE_U
-#elif defined(_M_MIPS)
-MACRO(STUBCODE_U, Name, SyscallId, ArgCount)
-    li $8, KUSER_SHARED_SYSCALL
-    lw $8,0($8)
-    j $8
-    nop
-ENDM
-MACRO(STUBCODE_K, Name, SyscallId, ArgCount)
-    j KiSystemService
-    nop
-ENDM
-#else
-#error unsupported architecture
-#endif
+    ret StackBytes
+ENDM
+MACRO(STUBCODE_K, Name, SyscallId, ArgCount)
+    StackBytes = 4 * &ArgCount
+    FPO 0, 0, 0, 0, 0, FRAME_FPO
+    mov eax, SyscallId
+    lea edx, [esp + 4]
+    pushfd
+    push KGDT_R0_CODE
+    call _KiSystemService
+    ret StackBytes
+ENDM
+#elif defined(_M_AMD64)
+MACRO(STUBCODE_U, Name, SyscallId, ArgCount)
+    .ENDPROLOG
+    mov eax, SyscallId
+    mov r10, rcx
+    syscall
+    ret
+ENDM
+MACRO(STUBCODE_K, Name, SyscallId, ArgCount)
+    .ENDPROLOG
+    EXTERN Nt&Name:PROC
+    lea rax, Nt&Name[rip]
+    mov r10, ArgCount * 8
+    jmp KiZwSystemService
+ENDM
+#elif defined(_M_PPC)
+MACRO(STUBCODE_U, Name, SyscallId, ArgCount)
+    stwu 1,-16(1)
+    mflr 0
+    stw  0,0(1)
+    li   0, SyscallId
+    sc
+    lwz 0,0(1)
+    mtlr 0
+    addi 1,1,16
+    blr
+ENDM
+#define STUBCODE_K STUBCODE_U
+#elif defined(_M_MIPS)
+MACRO(STUBCODE_U, Name, SyscallId, ArgCount)
+    li $8, KUSER_SHARED_SYSCALL
+    lw $8,0($8)
+    j $8
+    nop
+ENDM
+MACRO(STUBCODE_K, Name, SyscallId, ArgCount)
+    j KiSystemService
+    nop
+ENDM
+#else
+#error unsupported architecture
+#endif
+
+#ifdef _M_IX86
+MACRO(MAKE_LABEL, Name, StackBytes)
+    PUBLIC _&Name&@&StackBytes
+    _&Name&@&StackBytes:
+ENDM
+MACRO(START_PROC, Name, StackBytes)
+    PUBLIC _&Name&@&StackBytes
+    .PROC _&Name&@&StackBytes
+ENDM
+#else
+MACRO(MAKE_LABEL, Name, StackBytes)
+    PUBLIC &Name
+    &Name:
+ENDM
+MACRO(START_PROC, Name, StackBytes)
+    PUBLIC &Name
+    .PROC &Name
+ENDM
+#endif
+
+MACRO(STUB_U, Name, ArgCount)
+    MAKE_LABEL Zw&Name, %ArgCount * 4
+    MAKE_LABEL Name, %ArgCount * 4
+    START_PROC Nt&Name, %ArgCount * 4
+    STUBCODE_U Name, SyscallId, %ArgCount
+    .ENDP
+    SyscallId = SyscallId + 1
+ENDM
+
+MACRO(STUB_K, Name, ArgCount)
+    MAKE_LABEL Name, %ArgCount * 4
+    START_PROC Zw&Name, %ArgCount * 4
+    STUBCODE_K Name, SyscallId, %ArgCount
+    .ENDP
+    SyscallId = SyscallId + 1
+ENDM
 
-#ifdef _M_IX86
-MACRO(MAKE_LABEL, Name, StackBytes)
-    PUBLIC _&Name&@&StackBytes
-    _&Name&@&StackBytes:
-ENDM
-MACRO(START_PROC, Name, StackBytes)
-    PUBLIC _&Name&@&StackBytes
-    .PROC _&Name&@&StackBytes
-ENDM
-#else
-MACRO(MAKE_LABEL, Name, StackBytes)
-    PUBLIC &Name
-    &Name:
-ENDM
-MACRO(START_PROC, Name, StackBytes)
-    PUBLIC &Name
-    .PROC &Name
-ENDM
 #endif
-
-MACRO(STUB_U, Name, ArgCount)
-    MAKE_LABEL Zw&Name, %ArgCount * 4
-    START_PROC Nt&Name, %ArgCount * 4
-    STUBCODE_U Name, SyscallId, %ArgCount
-    .ENDP
-    SyscallId = SyscallId + 1
-ENDM
-
-MACRO(STUB_K, Name, ArgCount)
-    START_PROC Zw&Name, %ArgCount * 4
-    STUBCODE_K Name, SyscallId, %ArgCount
-    .ENDP
-    SyscallId = SyscallId + 1
-ENDM
-
-#endif
Index: include/psdk/winddi.h
===================================================================
--- include/psdk/winddi.h	(revision 70340)
+++ include/psdk/winddi.h	(working copy)
@@ -2911,7 +2911,7 @@
     _In_ ULONG cjSize,
     _Out_bytecap_(cjSize) FONTINFO *pfi);
 
-#if (NTDDI_VERSION <= NTDDI_WINXP)
+#if 0//(NTDDI_VERSION <= NTDDI_WINXP)
  /* Obsolete in Windows 2000 and later */
 GAMMA_TABLES*
 APIENTRY
Index: include/reactos/wine/config.h
===================================================================
--- include/reactos/wine/config.h	(revision 70340)
+++ include/reactos/wine/config.h	(working copy)
@@ -1,3 +1,5 @@
+#include "reactos/buildno.h"
+
 #define __WINE_CONFIG_H
 
 /* Define to a function attribute for Microsoft hotpatch assembly prefix. */
Index: lib/3rdparty/CMakeLists.txt
===================================================================
--- lib/3rdparty/CMakeLists.txt	(revision 70340)
+++ lib/3rdparty/CMakeLists.txt	(working copy)
@@ -2,7 +2,9 @@
 add_subdirectory(adns)
 add_subdirectory(bzip2)
 add_subdirectory(cardlib)
+if (NOT _ARWINSS_)
 add_subdirectory(freetype)
+endif ()
 add_subdirectory(fullfat)
 add_subdirectory(libmpg123)
 add_subdirectory(libsamplerate)
Index: subsystems/win32/csrsrv/init.c
===================================================================
--- subsystems/win32/csrsrv/init.c	(revision 70340)
+++ subsystems/win32/csrsrv/init.c	(working copy)
@@ -20,7 +20,7 @@
 /* DATA ***********************************************************************/
 
 // Debug Flag
-ULONG CsrDebug = 0; // 0xFFFFFFFF;
+ULONG CsrDebug = 0xFFFFFFFF;
 
 HANDLE CsrHeap = NULL;
 HANDLE CsrObjectDirectory = NULL;
Index: win32ss/CMakeLists.txt
===================================================================
--- win32ss/CMakeLists.txt	(revision 70340)
+++ win32ss/CMakeLists.txt	(working copy)
@@ -10,7 +10,10 @@
 PROJECT(WIN32SS)
 
 add_subdirectory(drivers)
+add_subdirectory(user/winsrv)
 
+if (NOT _ARWINSS_)
+
 if(USE_DIBLIB)
     add_subdirectory(gdi/diblib)
 endif()
@@ -18,7 +21,6 @@
 add_subdirectory(gdi/gdi32)
 add_subdirectory(reactx)
 add_subdirectory(user/user32)
-add_subdirectory(user/winsrv)
 
 spec2def(win32k.sys win32k.spec ADD_IMPORTLIB)
 
@@ -243,3 +245,4 @@
 add_asm_files(win32ksys_asm sys-stubs.S)
 add_library(win32ksys ${win32ksys_asm})
 set_target_properties(win32ksys PROPERTIES LINKER_LANGUAGE "C")
+endif() # _ARWINSS_
\ No newline at end of file
Index: win32ss/drivers/CMakeLists.txt
===================================================================
--- win32ss/drivers/CMakeLists.txt	(revision 70340)
+++ win32ss/drivers/CMakeLists.txt	(working copy)
@@ -1,6 +1,8 @@
 
 add_subdirectory(displays)
+if (NOT _ARWINSS_)
 add_subdirectory(font)
+endif ()
 add_subdirectory(miniport)
 add_subdirectory(videoprt)
 add_subdirectory(watchdog)
Index: win32ss/include/ntgdihdl.h
===================================================================
--- win32ss/include/ntgdihdl.h	(revision 70340)
+++ win32ss/include/ntgdihdl.h	(working copy)
@@ -260,6 +260,7 @@
     DWORD           dwCFCount;
 } GDI_SHARED_HANDLE_TABLE, *PGDI_SHARED_HANDLE_TABLE;
 
+#ifndef _ARWINSS_
 typedef struct _RGN_ATTR
 {
     ULONG AttrFlags;
@@ -347,6 +348,19 @@
     RGN_ATTR VisRectRegion;
 } DC_ATTR, *PDC_ATTR;
 
+#else
+
+typedef struct _DC_ATTR
+{
+    HDC  hdc;
+    HDC  hKernelDC;
+    RECT dc_rect;     /* DC rectangle relative to drawable */
+    HRGN region;      /* Device region (visible region & clip region) */
+    int  cache_index; /* cache of a currently selected font */
+} DC_ATTR, *PDC_ATTR;
+
+#endif
+
 typedef struct _BRUSH_ATTR /* Used with pen too. */
 {
     FLONG    AttrFlags;
Index: win32ss/user/winsrv/consrv/conoutput.c
===================================================================
--- win32ss/user/winsrv/consrv/conoutput.c	(revision 70340)
+++ win32ss/user/winsrv/consrv/conoutput.c	(working copy)
@@ -99,9 +99,13 @@
      * Indeed, the palette handle comes from a console app
      * calling ourselves, running in CSRSS.
      */
+#ifndef _ARWINSS_
     NtUserConsoleControl(ConsoleMakePalettePublic,
                          &SetPaletteRequest->PaletteHandle,
                          sizeof(SetPaletteRequest->PaletteHandle));
+#else
+	UNIMPLEMENTED;
+#endif
 
     Status = ConDrvSetConsolePalette(Buffer->Header.Console,
                                      Buffer,
Index: win32ss/user/winsrv/consrv/frontends/gui/conwnd.c
===================================================================
--- win32ss/user/winsrv/consrv/frontends/gui/conwnd.c	(revision 70340)
+++ win32ss/user/winsrv/consrv/frontends/gui/conwnd.c	(working copy)
@@ -159,7 +159,11 @@
     }
     else
     {
+#ifndef _ARWINSS_
         NtUserConsoleControl(GuiConsoleWndClassAtom, &WndClassAtom, sizeof(ATOM));
+#else
+        UNIMPLEMENTED;
+#endif
     }
 
     return (WndClassAtom != 0);
Index: win32ss/user/winsrv/consrv/frontends/gui/guiterm.c
===================================================================
--- win32ss/user/winsrv/consrv/frontends/gui/guiterm.c	(revision 70340)
+++ win32ss/user/winsrv/consrv/frontends/gui/guiterm.c	(working copy)
@@ -161,9 +161,14 @@
     /* Assign this console input thread to this desktop */
     DesktopConsoleThreadInfo.DesktopHandle = GuiInitInfo->Desktop; // Duplicated desktop handle
     DesktopConsoleThreadInfo.ThreadId = InputThreadId;
+#ifndef _ARWINSS_
     Status = NtUserConsoleControl(ConsoleCtrlDesktopConsoleThread,
                                   &DesktopConsoleThreadInfo,
                                   sizeof(DesktopConsoleThreadInfo));
+#else
+    UNIMPLEMENTED;
+    Status = STATUS_UNSUCCESSFUL;
+#endif
     if (!NT_SUCCESS(Status)) goto Quit;
 
     /* Connect this CSR thread to the USER subsystem */
@@ -301,9 +306,13 @@
     /* Remove this console input thread from this desktop */
     // DesktopConsoleThreadInfo.DesktopHandle;
     DesktopConsoleThreadInfo.ThreadId = 0;
+#ifndef _ARWINSS_
     NtUserConsoleControl(ConsoleCtrlDesktopConsoleThread,
                          &DesktopConsoleThreadInfo,
                          sizeof(DesktopConsoleThreadInfo));
+#else
+    UNIMPLEMENTED
+#endif
 
     /* Close the duplicated desktop handle */
     CloseDesktop(DesktopConsoleThreadInfo.DesktopHandle); // NtUserCloseDesktop
@@ -366,11 +375,16 @@
     {
         RtlInitUnicodeString(&DesktopPath, L"Default");
     }
-
+#ifndef _ARWINSS_
     hDesk = NtUserResolveDesktop(ConsoleLeaderProcessHandle,
                                  &DesktopPath,
                                  0,
                                  &hWinSta);
+#else
+    UNIMPLEMENTED
+    hDesk = NULL;
+#endif
+
     DPRINT("NtUserResolveDesktop(DesktopPath = '%wZ') returned hDesk = 0x%p; hWinSta = 0x%p\n",
            &DesktopPath, hDesk, hWinSta);
 
Index: win32ss/user/winsrv/usersrv/init.c
===================================================================
--- win32ss/user/winsrv/usersrv/init.c	(revision 70340)
+++ win32ss/user/winsrv/usersrv/init.c	(working copy)
@@ -199,9 +199,14 @@
 
     /* Pass the request to win32k */
     ConnectInfo->dwDispatchCount = 0; // gDispatchTableValues;
+#ifndef _ARWINSS_
     Status = NtUserProcessConnect(CsrProcess->ProcessHandle,
                                   ConnectInfo,
                                   *ConnectionInfoLength);
+#else
+    Status = STATUS_SUCCESS;
+    UNIMPLEMENTED
+#endif
 
     return Status;
 }
@@ -254,7 +259,11 @@
     }
 
     /* Set the process creation notify routine for BASE */
+#ifndef _ARWINSS_
     BaseSetProcessCreateNotify(NtUserNotifyProcessCreate);
+#else
+    UNIMPLEMENTED
+#endif
 
     /* Initialize the kernel mode subsystem */
     Status = NtUserInitialize(USER_VERSION,
Index: win32ss/user/winsrv/usersrv/shutdown.c
===================================================================
--- win32ss/user/winsrv/usersrv/shutdown.c	(revision 70340)
+++ win32ss/user/winsrv/usersrv/shutdown.c	(working copy)
@@ -381,7 +381,12 @@
 static BOOLEAN
 IsConsoleMode(VOID)
 {
+#ifndef _ARWINSS_
     return (BOOLEAN)NtUserCallNoParam(NOPARAM_ROUTINE_ISCONSOLEMODE);
+#else
+    UNIMPLEMENTED
+    return FALSE;
+#endif
 }
 
 
