diff -U 3 -P -r bochs-2.3.6\cpu\cpu.h bochs-2.3.6-poison\cpu\cpu.h
--- bochs-2.3.6\cpu\cpu.h	Sat Dec 22 18:17:40 2007
+++ bochs-2.3.6-poison\cpu\cpu.h	Thu May 22 23:19:39 2008
@@ -29,6 +29,7 @@
 #ifndef BX_CPU_H
 #  define BX_CPU_H 1

+#include <set>
 #include <setjmp.h>

 #include "cpu/lazy_flags.h"
@@ -3521,6 +3522,11 @@
   BX_SMF bx_bool    is_monitor(bx_phy_address addr, unsigned len);
   BX_SMF void    check_monitor(bx_phy_address addr, unsigned len);
 #endif
+
+  std::set<bx_address> poisoned_bytes_read;
+  std::set<bx_address> poisoned_bytes_write;
+  BX_SMF void BxPoison(bxInstruction_c *);
+  BX_SMF void REP_BxPoison(bxInstruction_c *);
 };

 #if BX_SUPPORT_ICACHE
diff -U 3 -P -r bochs-2.3.6\cpu\fetchdecode.cpp bochs-2.3.6-poison\cpu\fetchdecode.cpp
--- bochs-2.3.6\cpu\fetchdecode.cpp	Sat Dec 22 18:17:40 2007
+++ bochs-2.3.6-poison\cpu\fetchdecode.cpp	Sat May 24 06:01:56 2008
@@ -521,7 +521,7 @@
   /* 0F 24 /wr */ { BxTraceEnd, &BX_CPU_C::MOV_RdTd }, // not implemented
   /* 0F 25 /wr */ { 0, &BX_CPU_C::BxError },
   /* 0F 26 /wr */ { BxTraceEnd, &BX_CPU_C::MOV_TdRd }, // not implemented
-  /* 0F 27 /wr */ { 0, &BX_CPU_C::BxError },
+  /* 0F 27 /wr */ { BxRepeatable, &BX_CPU_C::REP_BxPoison },
   /* 0F 28 /wr */ { BxPrefixSSE, NULL, BxOpcodeGroupSSE_0f28 },
   /* 0F 29 /wr */ { BxPrefixSSE, NULL, BxOpcodeGroupSSE_0f29 },
   /* 0F 2A /wr */ { BxPrefixSSE, NULL, BxOpcodeGroupSSE_0f2a },
@@ -2971,4 +2971,40 @@
   BX_DEBUG(("WARNING: Encountered an unknown i (signalling illegal i)"));

   BX_CPU_THIS_PTR UndefinedOpcode(i);
+}
+
+void BX_CPU_C::BxPoison(bxInstruction_c * i)
+{
+  bool poison_read    = !!(EAX & 0x00000001);
+  bool poison_write   = !!(EAX & 0x00000002);
+  bool unpoison_read  = !!(EAX & 0x00000004);
+  bool unpoison_write = !!(EAX & 0x00000008);
+
+  if (poison_read)
+    BX_CPU_THIS_PTR poisoned_bytes_read.insert(ESI);
+
+  if (poison_write)
+    BX_CPU_THIS_PTR poisoned_bytes_write.insert(ESI);
+
+  if (unpoison_read)
+    BX_CPU_THIS_PTR poisoned_bytes_read.erase(ESI);
+
+  if (unpoison_write)
+    BX_CPU_THIS_PTR poisoned_bytes_write.erase(ESI);
+
+  if (BX_CPU_THIS_PTR get_DF())
+    RSI = ESI - 1;
+  else
+    RSI = ESI + 1;
+}
+
+void BX_CPU_C::REP_BxPoison(bxInstruction_c * i)
+{
+  if (!real_mode() && CPL!=0) {
+    BX_ERROR(("POISON: privilege check failed, generating #GP(0)"));
+    exception(BX_GP_EXCEPTION, 0, 0);
+  }
+
+  BX_CPU_THIS_PTR repeat(i, &BX_CPU_C::BxPoison);
+  BX_DEBUG(("POISON: %lu r, %lu w", (unsigned long)(BX_CPU_THIS_PTR poisoned_bytes_read.size()), (unsigned long)(BX_CPU_THIS_PTR poisoned_bytes_write.size())));
 }
diff -U 3 -P -r bochs-2.3.6\cpu\paging.cpp bochs-2.3.6-poison\cpu\paging.cpp
--- bochs-2.3.6\cpu\paging.cpp	Sun Dec 23 18:21:28 2007
+++ bochs-2.3.6-poison\cpu\paging.cpp	Fri May 23 17:44:29 2008
@@ -1114,6 +1114,34 @@

 void BX_CPU_C::access_linear(bx_address laddr, unsigned len, unsigned curr_pl, unsigned rw, void *data)
 {
+#if 1
+  if ((rw == BX_READ || rw == BX_RW) && !BX_CPU_THIS_PTR poisoned_bytes_read.empty())
+  {
+    bx_address testaddr = laddr;
+
+    for (unsigned i = 0; i < len; ++ i, ++ testaddr)
+    {
+      if (BX_CPU_THIS_PTR poisoned_bytes_read.count(testaddr)) {
+        BX_ERROR(("Code at %08X was poisoned by reading from %08X", (Bit32u) RIP, (Bit32u) laddr));
+        exception (BX_BP_EXCEPTION, 0, 0);
+	  }
+    }
+  }
+
+  if ((rw == BX_WRITE || rw == BX_RW) && !BX_CPU_THIS_PTR poisoned_bytes_write.empty())
+  {
+    bx_address testaddr = laddr;
+
+    for (unsigned i = 0; i < len; ++ i, ++ testaddr)
+    {
+      if (BX_CPU_THIS_PTR poisoned_bytes_write.count(testaddr)) {
+        BX_ERROR(("Code at %08X was poisoned by writing to %08X", (Bit32u) RIP, (Bit32u) laddr));
+        exception (BX_BP_EXCEPTION, 0, 0);
+	  }
+    }
+  }
+#endif
+
 #if BX_X86_DEBUGGER
   hwbreakpoint_match(laddr, len, rw);
 #endif
